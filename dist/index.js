class _ extends Error{response;request;options;constructor(t,e,o){const r=t.status||t.status===0?t.status:"",n=t.statusText||"",i=`${r} ${n}`.trim(),a=i?`status code ${i}`:"an unknown error";super(`Request failed with ${a}: ${e.method} ${e.url}`),this.name="HTTPError",this.response=t,this.request=e,this.options=o}}class w extends Error{request;constructor(t){super(`Request timed out: ${t.method} ${t.url}`),this.name="TimeoutError",this.request=t}}const h=s=>s!==null&&typeof s=="object",p=(...s)=>{for(const t of s)if((!h(t)||Array.isArray(t))&&t!==void 0)throw new TypeError("The `options` argument must be an object");return m({},...s)},R=(s={},t={})=>{const e=new globalThis.Headers(s),o=t instanceof globalThis.Headers,r=new globalThis.Headers(t);for(const[n,i]of r.entries())o&&i==="undefined"||i===void 0?e.delete(n):e.set(n,i);return e};function l(s,t,e){return Object.hasOwn(t,e)&&t[e]===void 0?[]:m(s[e]??[],t[e]??[])}const T=(s={},t={})=>({beforeRequest:l(s,t,"beforeRequest"),beforeRetry:l(s,t,"beforeRetry"),afterResponse:l(s,t,"afterResponse"),beforeError:l(s,t,"beforeError")}),m=(...s)=>{let t={},e={},o={};for(const r of s)if(Array.isArray(r))Array.isArray(t)||(t=[]),t=[...t,...r];else if(h(r)){for(let[n,i]of Object.entries(r))h(i)&&n in t&&(i=m(t[n],i)),t={...t,[n]:i};h(r.hooks)&&(o=T(o,r.hooks),t.hooks=o),h(r.headers)&&(e=R(e,r.headers),t.headers=e)}return t},C=(()=>{let s=!1,t=!1;const e=typeof globalThis.ReadableStream=="function",o=typeof globalThis.Request=="function";if(e&&o)try{t=new globalThis.Request("https://empty.invalid",{body:new globalThis.ReadableStream,method:"POST",get duplex(){return s=!0,"half"}}).headers.has("Content-Type")}catch(r){if(r instanceof Error&&r.message==="unsupported BodyInit type")return!1;throw r}return s&&!t})(),P=typeof globalThis.AbortController=="function",I=typeof globalThis.ReadableStream=="function",v=typeof globalThis.FormData=="function",k=["get","post","put","patch","head","delete"],U={json:"application/json",text:"text/*",formData:"multipart/form-data",arrayBuffer:"*/*",blob:"*/*"},d=2147483647,q=Symbol("stop"),$={json:!0,parseJson:!0,stringifyJson:!0,searchParams:!0,prefixUrl:!0,retry:!0,timeout:!0,hooks:!0,throwHttpErrors:!0,onDownloadProgress:!0,fetch:!0},j={method:!0,headers:!0,body:!0,mode:!0,credentials:!0,cache:!0,redirect:!0,referrer:!0,referrerPolicy:!0,integrity:!0,keepalive:!0,signal:!0,window:!0,dispatcher:!0,duplex:!0,priority:!0},O=s=>k.includes(s)?s.toUpperCase():s,L=["get","put","head","delete","options","trace"],H=[408,413,429,500,502,503,504],N=[413,429,503],g={limit:2,methods:L,statusCodes:H,afterStatusCodes:N,maxRetryAfter:Number.POSITIVE_INFINITY,backoffLimit:Number.POSITIVE_INFINITY,delay:s=>.3*2**(s-1)*1e3},M=(s={})=>{if(typeof s=="number")return{...g,limit:s};if(s.methods&&!Array.isArray(s.methods))throw new Error("retry.methods must be an array");if(s.statusCodes&&!Array.isArray(s.statusCodes))throw new Error("retry.statusCodes must be an array");return{...g,...s}};async function V(s,t,e,o){return new Promise((r,n)=>{const i=setTimeout(()=>{e&&e.abort(),n(new w(s))},o.timeout);o.fetch(s,t).then(r).catch(n).then(()=>{clearTimeout(i)})})}async function B(s,{signal:t}){return new Promise((e,o)=>{t&&(t.throwIfAborted(),t.addEventListener("abort",r,{once:!0}));function r(){clearTimeout(n),o(t.reason)}const n=setTimeout(()=>{t?.removeEventListener("abort",r),e()},s)})}const D=(s,t)=>{const e={};for(const o in t)!(o in j)&&!(o in $)&&!(o in s)&&(e[o]=t[o]);return e};class f{static create(t,e){const o=new f(t,e),r=async()=>{if(typeof o._options.timeout=="number"&&o._options.timeout>d)throw new RangeError(`The \`timeout\` option cannot be greater than ${d}`);await Promise.resolve();let a=await o._fetch();for(const c of o._options.hooks.afterResponse){const u=await c(o.request,o._options,o._decorateResponse(a.clone()));u instanceof globalThis.Response&&(a=u)}if(o._decorateResponse(a),!a.ok&&o._options.throwHttpErrors){let c=new _(a,o.request,o._options);for(const u of o._options.hooks.beforeError)c=await u(c);throw c}if(o._options.onDownloadProgress){if(typeof o._options.onDownloadProgress!="function")throw new TypeError("The `onDownloadProgress` option must be a function");if(!I)throw new Error("Streams are not supported in your environment. `ReadableStream` is missing.");return o._stream(a.clone(),o._options.onDownloadProgress)}return a},i=o._options.retry.methods.includes(o.request.method.toLowerCase())?o._retry(r):r();for(const[a,c]of Object.entries(U))i[a]=async()=>{o.request.headers.set("accept",o.request.headers.get("accept")||c);const u=await i;if(a==="json"){if(u.status===204||(await u.clone().arrayBuffer()).byteLength===0)return"";if(e.parseJson)return e.parseJson(await u.text())}return u[a]()};return i}request;abortController;_retryCount=0;_input;_options;constructor(t,e={}){if(this._input=t,this._options={...e,headers:R(this._input.headers,e.headers),hooks:T({beforeRequest:[],beforeRetry:[],beforeError:[],afterResponse:[]},e.hooks),method:O(e.method??this._input.method??"GET"),prefixUrl:String(e.prefixUrl||""),retry:M(e.retry),throwHttpErrors:e.throwHttpErrors!==!1,timeout:e.timeout??1e4,fetch:e.fetch??globalThis.fetch.bind(globalThis)},typeof this._input!="string"&&!(this._input instanceof URL||this._input instanceof globalThis.Request))throw new TypeError("`input` must be a string, URL, or Request");if(this._options.prefixUrl&&typeof this._input=="string"){if(this._input.startsWith("/"))throw new Error("`input` must not begin with a slash when using `prefixUrl`");this._options.prefixUrl.endsWith("/")||(this._options.prefixUrl+="/"),this._input=this._options.prefixUrl+this._input}if(P){this.abortController=new globalThis.AbortController;const o=this._options.signal??this._input.signal;o?.aborted&&this.abortController.abort(o?.reason),o?.addEventListener("abort",()=>{this.abortController.abort(o.reason)}),this._options.signal=this.abortController.signal}if(C&&(this._options.duplex="half"),this._options.json!==void 0&&(this._options.body=this._options.stringifyJson?.(this._options.json)??JSON.stringify(this._options.json),this._options.headers.set("content-type",this._options.headers.get("content-type")??"application/json")),this.request=new globalThis.Request(this._input,this._options),this._options.searchParams){const r="?"+(typeof this._options.searchParams=="string"?this._options.searchParams.replace(/^\?/,""):new URLSearchParams(this._options.searchParams).toString()),n=this.request.url.replace(/(?:\?.*?)?(?=#|$)/,r);(v&&this._options.body instanceof globalThis.FormData||this._options.body instanceof URLSearchParams)&&!(this._options.headers&&this._options.headers["content-type"])&&this.request.headers.delete("content-type"),this.request=new globalThis.Request(new globalThis.Request(n,{...this.request}),this._options)}}_calculateRetryDelay(t){if(this._retryCount++,this._retryCount>this._options.retry.limit||t instanceof w)throw t;if(t instanceof _){if(!this._options.retry.statusCodes.includes(t.response.status))throw t;const o=t.response.headers.get("Retry-After")??t.response.headers.get("RateLimit-Reset")??t.response.headers.get("X-RateLimit-Reset")??t.response.headers.get("X-Rate-Limit-Reset");if(o&&this._options.retry.afterStatusCodes.includes(t.response.status)){let r=Number(o)*1e3;Number.isNaN(r)?r=Date.parse(o)-Date.now():r>=Date.parse("2024-01-01")&&(r-=Date.now());const n=this._options.retry.maxRetryAfter??r;return r<n?r:n}if(t.response.status===413)throw t}const e=this._options.retry.delay(this._retryCount);return Math.min(this._options.retry.backoffLimit,e)}_decorateResponse(t){return this._options.parseJson&&(t.json=async()=>this._options.parseJson(await t.text())),t}async _retry(t){try{return await t()}catch(e){const o=Math.min(this._calculateRetryDelay(e),d);if(this._retryCount<1)throw e;await B(o,{signal:this._options.signal});for(const r of this._options.hooks.beforeRetry)if(await r({request:this.request,options:this._options,error:e,retryCount:this._retryCount})===q)return;return this._retry(t)}}async _fetch(){for(const o of this._options.hooks.beforeRequest){const r=await o(this.request,this._options);if(r instanceof Request){this.request=r;break}if(r instanceof Response)return r}const t=D(this.request,this._options),e=this.request;return this.request=e.clone(),this._options.timeout===!1?this._options.fetch(e,t):V(e,t,this.abortController,this._options)}_stream(t,e){const o=Number(t.headers.get("content-length"))||0;let r=0;return t.status===204?(e&&e({percent:1,totalBytes:o,transferredBytes:r},new Uint8Array),new globalThis.Response(null,{status:t.status,statusText:t.statusText,headers:t.headers})):new globalThis.Response(new globalThis.ReadableStream({async start(n){const i=t.body.getReader();e&&e({percent:0,transferredBytes:0,totalBytes:o},new Uint8Array);async function a(){const{done:c,value:u}=await i.read();if(c){n.close();return}if(e){r+=u.byteLength;const b=o===0?0:r/o;e({percent:b,transferredBytes:r,totalBytes:o},u)}n.enqueue(u),await a()}await a()}}),{status:t.status,statusText:t.statusText,headers:t.headers})}}/*! MIT License Â© Sindre Sorhus */const y=s=>{const t=(e,o)=>f.create(e,p(s,o));for(const e of k)t[e]=(o,r)=>f.create(o,p(s,r,{method:e}));return t.create=e=>y(p(e)),t.extend=e=>(typeof e=="function"&&(e=e(s??{})),y(p(s,e))),t.stop=q,t},J=y(),S=J.create({hooks:{beforeRequest:[s=>{const t=z();s.headers.set("Authorization","bearer "+t)}]}}),x="https://api.vimeo.com",z=()=>localStorage.getItem("accessToken")??"c2276962367652679c309e1bb60167b7",E=s=>{const t=s.uri.split("/").pop();return{title:s.name,duration:s.duration,apiId:t,likes:s.metadata.connections.likes.total,description:s.description,views:s.stats.plays,images:s.pictures.sizes.map(e=>({width:e.width,height:e.height,url:e.link})),originalUrl:`https://vimeo.com/${t}`}},F=async s=>{const t=`${x}/videos/${s.apiId}`,e=await S.get(t).json();return E(e)},A=async s=>{const e=s.pageInfo?.offset||0,o=e/20+1,n=`${`${x}/videos`}?per_page=20&query=${s.query}&page=${o}`,i=await S.get(n).json(),a={offset:e,resultsPerPage:20,totalResults:i.total};return{items:i.data.map(E),pageInfo:a}},W=s=>{application.postUiMessage(s)},G=async()=>{const s=localStorage.getItem("accessToken")??"";W({type:"send-info",accessToken:s})};application.onUiMessage=async s=>{switch(s.type){case"get-info":await G();break;case"set-keys":localStorage.setItem("accessToken",s.accessToken),application.createNotification({message:"Api keys Saved!"});break;case"endvideo":application.endVideo();break}};const X=async s=>{const t=A(s),[e]=await Promise.all([t]);return{videos:e}};application.onSearchAll=X;application.onSearchVideos=A;application.onGetVideo=F;
